# Прочитати дійсну матрицю розміром n * n, n - непарне. Надрукувати елементи матриці за таким шаблоном: починаючи з
# центрального елемента, вправо, по спіралі за годинниковою стрілкою. Приклад: для матриці 3 * 3,
# що містить елементи від 1 до 9, починаючи з першого рядка, результатом буде: 5 6 9 8 7 4 1 2 3
while True:  # легша реалізація контролю помилок, ніж через функцію
    try:  # режим вводу, ручний і тест, ручний - float
        matrix = list(map(float, input("Введіть матрицю n * n, n - непарне:\n\t").split())) \
            if (input_value := 0) else [n for n in range(1, 9 + 1)]  # тест
    except ValueError:  # перевірка №1: чи ввели числа, чи інші символи
        print("Введіть числа")
    else:
        if not (quantity := len(matrix)):  # перевірка №2: чи ввели непусту множину
            print("Введіть непусту множину")
        elif (n := quantity ** 0.5) % 1:  # перевірка №3: чи ввели n² елементів
            print("Введіть n² елементів")
        elif not (n := int(n)) % 2:  # перевірка №3: чи ввели непарну кількість елементів
            print("Введіть непарну кількість елементів")
        else:
            break


# сама програма
def increment_cycle(duration, step):  # приріст сторони
    global last  # глобалізація локальної змінної, яка вже існувала
    for _ in range(duration):  # наростаюча сторона спіралі, задана i, рядок 32
        last += step  # ±1 - переміщення по горизонталі, ±n - по вертикалі
        output.append(matrix[last])  # додає елемент спіралі, 31 рядок - перший елемент - це центр


# алгоритм: вправо 1, вниз 1, (1 цикл for), вліво 2, вверх 2, (2 цикл for), ... //16.1 секунд для 10001², 7GB RAM
last = round(quantity / 2)  # python використовує bankers rounding, яке округляє до найближчого парного (-1)
output = [matrix[last]]  # далі для прискорення створюється 2-рівневий генератор: ((1, 1), (2, -1), (3, 1))
for i, j in ((k, 2 * (k % 2) - 1) for k in range(1, n)):  # 2 * (k % 2) - 1 швидше, ніж -(-1) ** k, тест.
    increment_cycle(i, j), increment_cycle(i, j * n)  # приріст 2 сусідніх сторін квадрата
increment_cycle(n - 1, 1), print(*output)  # верхня горизонталь n - 1, надрукувати розархівований список
